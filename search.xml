<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DR_CAN课程学习——动态系统建模与分析</title>
    <url>/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p><strong>前言</strong></p>
<p>基于B站UP主<strong>DR_CAN</strong>视频所作总结笔记</p>
<p>视频链接：<a href="https://space.bilibili.com/230105574/channel/seriesdetail?sid=1569598">DR_CAN——动态系统建模与分析</a></p>
</blockquote>
<h2 id="电路系统建模、基尔霍夫定律"><a href="#电路系统建模、基尔霍夫定律" class="headerlink" title="电路系统建模、基尔霍夫定律"></a>电路系统建模、基尔霍夫定律</h2><span id="more"></span>
<p><img src="/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/动态系统的建模与分析-02.jpg" alt="动态系统的建模与分析-02" style="zoom:80%;"></p>
<hr>
<h2 id="流体系统建模"><a href="#流体系统建模" class="headerlink" title="流体系统建模"></a>流体系统建模</h2><p><img src="/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/动态系统的建模与分析-03.jpg" alt="动态系统的建模与分析-03" style="zoom:80%;"></p>
<hr>
<h2 id="拉普拉斯变换"><a href="#拉普拉斯变换" class="headerlink" title="拉普拉斯变换"></a>拉普拉斯变换</h2><p><img src="/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/动态系统的建模与分析-04.jpg" alt="动态系统的建模与分析-04" style="zoom:80%;"></p>
<hr>
<h2 id="拉氏变换收敛域、逆变换、传递函数"><a href="#拉氏变换收敛域、逆变换、传递函数" class="headerlink" title="拉氏变换收敛域、逆变换、传递函数"></a>拉氏变换收敛域、逆变换、传递函数</h2><p><img src="/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/动态系统的建模与分析-05.jpg" alt="动态系统的建模与分析-05" style="zoom:80%;"></p>
<hr>
<h2 id="一阶系统的单位阶跃响应"><a href="#一阶系统的单位阶跃响应" class="headerlink" title="一阶系统的单位阶跃响应"></a>一阶系统的单位阶跃响应</h2><p><img src="/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/动态系统的建模与分析-06.jpg" alt="动态系统的建模与分析-06" style="zoom:80%;"></p>
<hr>
<h2 id="频率响应"><a href="#频率响应" class="headerlink" title="频率响应"></a>频率响应</h2><p><img src="/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/动态系统的建模与分析-07.jpg" alt="动态系统的建模与分析-07" style="zoom:80%;"></p>
<hr>
<h2 id="一阶系统频率响应"><a href="#一阶系统频率响应" class="headerlink" title="一阶系统频率响应"></a>一阶系统频率响应</h2><p><img src="/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/动态系统的建模与分析-08.jpg" alt="动态系统的建模与分析-08" style="zoom:80%;"></p>
<hr>
<h2 id="二阶系统对初始条件的动态响应"><a href="#二阶系统对初始条件的动态响应" class="headerlink" title="二阶系统对初始条件的动态响应"></a>二阶系统对初始条件的动态响应</h2><p><img src="/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/动态系统的建模与分析-10.jpg" alt="动态系统的建模与分析-10" style="zoom:80%;"></p>
<hr>
<h2 id="二阶系统单位阶跃响应"><a href="#二阶系统单位阶跃响应" class="headerlink" title="二阶系统单位阶跃响应"></a>二阶系统单位阶跃响应</h2><p><img src="/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/动态系统的建模与分析-10-16435516522085.jpg" alt="动态系统的建模与分析-10" style="zoom:80%;"></p>
<hr>
<h2 id="二阶系统的性能分析与比较"><a href="#二阶系统的性能分析与比较" class="headerlink" title="二阶系统的性能分析与比较"></a>二阶系统的性能分析与比较</h2><p><img src="/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/动态系统的建模与分析-11.jpg" alt="动态系统的建模与分析-11" style="zoom:80%;"></p>
<hr>
<h2 id="二阶系统频率响应"><a href="#二阶系统频率响应" class="headerlink" title="二阶系统频率响应"></a>二阶系统频率响应</h2><p><img src="/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/动态系统的建模与分析-12-16435516613716.jpg" alt="动态系统的建模与分析-12" style="zoom:80%;"></p>
<hr>
<h2 id="伯德图"><a href="#伯德图" class="headerlink" title="伯德图"></a>伯德图</h2><p><img src="/2022/01/30/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/动态系统的建模与分析-13.jpg" alt="动态系统的建模与分析-13" style="zoom:80%;"></p>
]]></content>
      <tags>
        <tag>DR_CAN</tag>
        <tag>Theoretical Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>DR_CAN课程学习——自动控制原理</title>
    <url>/2022/01/31/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>前言</strong></p>
<p>基于B站UP主<strong>DR_CAN</strong>视频所作总结笔记</p>
<p>视频链接：<a href="https://space.bilibili.com/230105574/channel/seriesdetail?sid=1569593">DR_CAN——自动控制原理</a></p>
</blockquote>
<span id="more"></span>
<h2 id="开环系统与闭环系统"><a href="#开环系统与闭环系统" class="headerlink" title="开环系统与闭环系统"></a>开环系统与闭环系统</h2><p><img src="/2022/01/31/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/自动控制原理-2.jpg" alt="自动控制原理-2" style="zoom:80%;"></p>
<h2 id="系统稳定性分析"><a href="#系统稳定性分析" class="headerlink" title="系统稳定性分析"></a>系统稳定性分析</h2><p><img src="/2022/01/31/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/自动控制原理-3.jpg" alt="自动控制原理-3" style="zoom:80%;"></p>
<h2 id="系统分析实例、比例控制器"><a href="#系统分析实例、比例控制器" class="headerlink" title="系统分析实例、比例控制器"></a>系统分析实例、比例控制器</h2><p><img src="/2022/01/31/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/自动控制原理-4.jpg" alt="自动控制原理-4" style="zoom:80%;"></p>
<h2 id="终值定理与稳态误差"><a href="#终值定理与稳态误差" class="headerlink" title="终值定理与稳态误差"></a>终值定理与稳态误差</h2><p><img src="/2022/01/31/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/自动控制原理-5.jpg" alt="自动控制原理-5" style="zoom:80%;"></p>
<h2 id="比例积分控制器"><a href="#比例积分控制器" class="headerlink" title="比例积分控制器"></a>比例积分控制器</h2><p><img src="/2022/01/31/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/自动控制原理-6.jpg" alt="自动控制原理-6" style="zoom:80%;"></p>
<h2 id="根轨迹"><a href="#根轨迹" class="headerlink" title="根轨迹"></a>根轨迹</h2><p><img src="/2022/01/31/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/自动控制原理-7.jpg" alt="自动控制原理-7" style="zoom:80%;"></p>
<h2 id="超前补偿器"><a href="#超前补偿器" class="headerlink" title="超前补偿器"></a>超前补偿器</h2><p><img src="/2022/01/31/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/自动控制原理-8.jpg" alt="自动控制原理-8" style="zoom:80%;"></p>
<h2 id="滞后补偿器"><a href="#滞后补偿器" class="headerlink" title="滞后补偿器"></a>滞后补偿器</h2><p><img src="/2022/01/31/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/自动控制原理-9.jpg" alt="自动控制原理-9" style="zoom:80%;"></p>
<h2 id="奈奎斯特稳定性判据"><a href="#奈奎斯特稳定性判据" class="headerlink" title="奈奎斯特稳定性判据"></a>奈奎斯特稳定性判据</h2><p><img src="/2022/01/31/DR-CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/自动控制原理-10.jpg" alt="自动控制原理-10" style="zoom:80%;"></p>
]]></content>
      <tags>
        <tag>DR_CAN</tag>
        <tag>Theoretical Learning</tag>
        <tag>Principle of automatic control</tag>
      </tags>
  </entry>
  <entry>
    <title>Dr_CAN课程学习——工程数学基础</title>
    <url>/2022/01/27/DR_CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p><strong>前言</strong></p>
<p>基于B站UP主<strong>DR_CAN</strong>视频所作的总结笔记</p>
<p>视频链接：<a href="https://space.bilibili.com/230105574/channel/seriesdetail?sid=1569595">DR_CAN——工程数学基础</a></p>
</blockquote>
<h2 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于一个给定的线性变换 $A$ ，它的特征向量 $v$ 经过这个线性变换的作用后，得到的新向量仍然与原来的 $v$ 保持在同一直线上，但其长度或方向或许会改变，即：</p>
<script type="math/tex; mode=display">
Av = \lambda v</script><p>其中 $\lambda$ 为标量，即特征向量的长度在该线性变换下缩放的比例，称为其特征值。</p>
<span id="more"></span>
<p>$e.g.$</p>
<p>将线性变换矩阵 $A$ 分别与向量 $v_1、v_2$ 相乘，看变换后向量是否与原向量保持同一直线上。</p>
<script type="math/tex; mode=display">
A=
\begin{pmatrix} 
1 & 1  \\ 
4 & -2  \\ 
\end{pmatrix} 、 

v_1 = 
\begin{pmatrix} 
1 \\ 
2 \\
\end{pmatrix}、

v_2 = 
\begin{pmatrix} 
1 \\ 
1 \\
\end{pmatrix}</script><p>可以发现 $v_2$ 在 $A$ 的作用下变换成 $2v_2$ 故满足其上述定义。</p>
<h3 id="求解特征值、特征向量"><a href="#求解特征值、特征向量" class="headerlink" title="求解特征值、特征向量"></a>求解特征值、特征向量</h3><script type="math/tex; mode=display">
Av = \lambda v \\
Av - \lambda v = 0 \\
(A - \lambda I)v = 0 (\ast)\\
|A - \lambda I| = 0</script><p><em>注：上式中 $(\ast)$式需要有非零解，则其行列式需为零</em></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="化对角矩阵"><a href="#化对角矩阵" class="headerlink" title="化对角矩阵"></a>化对角矩阵</h4><p><img src="/2022/01/27/DR_CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220128090348822.png" alt="image-20220128090348822" style="zoom:67%;"></p>
<h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p><img src="/2022/01/27/DR_CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220128090433204.png" alt="image-20220128090433204" style="zoom:67%;"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>加深了对于特征向量、特征值的理解</li>
<li>重温了特征值求解方法</li>
<li>理解了对角化公式的由来</li>
<li>理解了对角化在解耦过程中的应用</li>
</ol>
<hr>
<h2 id="线性化、泰勒级数、泰勒公式"><a href="#线性化、泰勒级数、泰勒公式" class="headerlink" title="线性化、泰勒级数、泰勒公式"></a>线性化、泰勒级数、泰勒公式</h2><h3 id="线性系统"><a href="#线性系统" class="headerlink" title="线性系统"></a>线性系统</h3><p>条件：满足叠加原理</p>
<ol>
<li>$x_1、x_2$ 为系统方程的解</li>
<li>$x_3 = k_1 x_1 + k_2 x_2$ （$k_1、k_2$ 为常数）</li>
<li>$x_3$ 为系统方程的解</li>
</ol>
<h3 id="泰勒级数"><a href="#泰勒级数" class="headerlink" title="泰勒级数"></a>泰勒级数</h3><p><img src="/2022/01/27/DR_CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220128092750222.png" alt="image-20220128092750222"></p>
<h3 id="线性化"><a href="#线性化" class="headerlink" title="线性化"></a>线性化</h3><p><img src="/2022/01/27/DR_CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/工程数学-4.jpg" alt="工程数学-4" style="zoom:67%;"></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><hr>
<h2 id="卷积含义、LTI的冲激响应及卷积"><a href="#卷积含义、LTI的冲激响应及卷积" class="headerlink" title="卷积含义、LTI的冲激响应及卷积"></a>卷积含义、LTI的冲激响应及卷积</h2><h3 id="LTI-System"><a href="#LTI-System" class="headerlink" title="LTI System"></a>LTI System</h3><p>满足<strong>叠加原理、时不变原理</strong>的系统称为线性时不变系统。</p>
<h3 id="LTI-中拉普拉斯变换与卷积的关系"><a href="#LTI-中拉普拉斯变换与卷积的关系" class="headerlink" title="LTI 中拉普拉斯变换与卷积的关系"></a>LTI 中拉普拉斯变换与卷积的关系</h3><p>系统表达</p>
<script type="math/tex; mode=display">
F(s)H(s)=X(s)</script><p>进行拉氏逆变换后，等于<strong>系统时域上输出与传函的卷积</strong></p>
<script type="math/tex; mode=display">
f(t)\ast h(t) = x(t)</script><h3 id="LTI-中冲激响应"><a href="#LTI-中冲激响应" class="headerlink" title="LTI 中冲激响应"></a>LTI 中冲激响应</h3><p>根据 LTI 的叠加性质，任意的输出可以视为<strong>多个冲激响应的叠加</strong></p>
<p>时间 $t$ 为第$i$ 个时刻冲激响应时间$i\Delta_T$，则系统输出：</p>
<script type="math/tex; mode=display">
X(t) = \sum_{i=0}^i \Delta_Tf(i\Delta_T)h_\Delta(t - i\Delta_T)</script><p>将$\Delta_T$ 趋向0取极限，则$\Delta_T = d\tau, i\Delta_T=\tau$</p>
<p>则此时有输出函数：</p>
<script type="math/tex; mode=display">
X(t) = \int_0^t f(\tau)h(t-\tau)d\tau \\
即:X(t)=f(t)\ast h(t)</script><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>根据本节的内容，其实任意的LTI 系统都可以由一系列的冲激响应去定义整个系统。那么如果我们在一个LTI 系统下输入一段信号并与一种近似冲激响应的信号做卷积处理，就可以理解为——我们把输入信号放在了对应的冲激响应的系统中。<em>（注：这部分MATLAB实践放在后续章节中去分析）</em></p>
<p>思考过程：连续的输入信号切割成每一个单位冲激响应与某一时刻输入信号大小的乘积，即$t$ 时刻的输入可以看作是$\Delta_Tf(t)$ 大小的单位冲击响应，然后根据LTI 系统的叠加原理，将$t$ 时刻前的所有输入响应进行叠加，即可得到$t$ 时刻的输出信号，$\Delta_T$ 去极限就是积分，也就得到最终的卷积形式。</p>
<p>视频最后的例子的理解：每一时刻说话的声音由一个个浴室帘后声音的冲激响应叠加组成，其冲激响应特点是沉闷的回声，所有进行卷积后得到了人躲在浴室帘后说话的感觉。</p>
<hr>
<h2 id="欧拉公式证明"><a href="#欧拉公式证明" class="headerlink" title="欧拉公式证明"></a>欧拉公式证明</h2><p><img src="/2022/01/27/DR_CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220128154702016.png" alt="image-20220128154702016"></p>
<hr>
<h2 id="卷积的拉普拉斯变换"><a href="#卷积的拉普拉斯变换" class="headerlink" title="卷积的拉普拉斯变换"></a>卷积的拉普拉斯变换</h2><p><img src="/2022/01/27/DR_CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220128154518972.png" alt="image-20220128154518972" style="zoom:100%;"></p>
<hr>
<h2 id="Sinx-2-的证明"><a href="#Sinx-2-的证明" class="headerlink" title="Sinx = 2 的证明"></a>Sinx = 2 的证明</h2><p><img src="/2022/01/27/DR_CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220128154552178.png" alt="image-20220128154552178"></p>
<hr>
<h2 id="复数的三种表示"><a href="#复数的三种表示" class="headerlink" title="复数的三种表示"></a>复数的三种表示</h2><h3 id="一般型"><a href="#一般型" class="headerlink" title="一般型"></a>一般型</h3><script type="math/tex; mode=display">
z = a + bi</script><h3 id="三角型"><a href="#三角型" class="headerlink" title="三角型"></a>三角型</h3><script type="math/tex; mode=display">
z = |z|cos(\theta) +|z|sin(\theta)i</script><h3 id="指数型"><a href="#指数型" class="headerlink" title="指数型"></a>指数型</h3><script type="math/tex; mode=display">
z = |z|e^{i\theta}</script><h3 id="欧拉恒等式"><a href="#欧拉恒等式" class="headerlink" title="欧拉恒等式"></a>欧拉恒等式</h3><p>当$\theta = \pi$  ，$|z|=1$有：</p>
<script type="math/tex; mode=display">
e^{i\pi} + 1 = 0</script><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>通过数形转换的方式，加深对这三种形式的理解</p>
<hr>
<h2 id="如何选取阈值"><a href="#如何选取阈值" class="headerlink" title="如何选取阈值"></a>如何选取阈值</h2><h3 id="Six-Sigma-选取原则"><a href="#Six-Sigma-选取原则" class="headerlink" title="Six Sigma 选取原则"></a>Six Sigma 选取原则</h3><p>工业生产中，对于产品的品质把控一般采用<strong>Six Sigma</strong>的原则。</p>
<p><img src="/2022/01/27/DR_CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220128153711471.png" alt="image-20220128153711471" style="zoom:67%;"></p>
<h3 id="工程选择两种准则"><a href="#工程选择两种准则" class="headerlink" title="工程选择两种准则"></a>工程选择两种准则</h3><p>当合格与不合格的Six Sigma存在重叠部分，那么根据实际情况选择<strong>宁纵无枉</strong>还是<strong>宁枉无纵</strong></p>
<p><img src="/2022/01/27/DR_CAN%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/image-20220128153947372.png" alt="image-20220128153947372" style="zoom:67%;"></p>
]]></content>
      <tags>
        <tag>DR_CAN</tag>
        <tag>Theoretical Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SLAM导航实战（一）：编程基础</title>
    <url>/2022/01/29/SLAM%E5%AF%BC%E8%88%AA%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p><strong>前言</strong></p>
<p>本系列主要基于《机器人SLAM导航——核心技术与实战》一书进行学习总结，根据作者对本书的章节规划，预计共分为四个部分：</p>
<ol>
<li>编程基础篇</li>
<li>硬件基础篇</li>
<li>SLAM篇</li>
<li>自主导航篇</li>
</ol>
<p>本系列笔记也将基于上述四个部分进行归纳总结</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当前SLAM系统主要是在<strong>Linux</strong>系统进行开发的，其中应用最广的当属<strong>Ubuntu</strong>，掌握Linux系统的基本操作是进行SLAM开发的前提条件。除了操作系统外，进行SLAM学习还需要掌握一些其他的必要的基础技能，也是本章的主要内容——<strong>ROS操作系统、C++编程基础、OpenCV基础</strong>。本章将依次对其内容进行简要的总结梳理（主要是采集里面对于自己有用的知识点）。</p>
<span id="more"></span>
<p><em>（注：笔者本人粗略查看了书籍第一部分内容，认为对无基础小白并不友好，需要有一定基础才能更好地学习此书，为此每个部分笔者也简单梳理自己的学习资料）</em></p>
<h2 id="ROS操作系统"><a href="#ROS操作系统" class="headerlink" title="ROS操作系统"></a>ROS操作系统</h2><h3 id="相关学习资料"><a href="#相关学习资料" class="headerlink" title="相关学习资料"></a>相关学习资料</h3><p>详细清晰，对小白友好：<a href="https://www.bilibili.com/video/BV1mJ411R7Ni?from=search&amp;seid=5450696048617681625&amp;spm_id_from=333.337.0.0">中科院ROS操作系统学习教程</a></p>
<p>版本较新，含实战内容：<a href="http://www.autolabor.com.cn/book/ROSTutorials/">Autolabor Ros教程</a></p>
<p>经典教程<del>（个人入门教程，但没太学明白）</del>：<a href="https://www.bilibili.com/video/BV1zt411G7Vn?from=search&amp;seid=5450696048617681625&amp;spm_id_from=333.337.0.0">古月居ROS 21讲</a></p>
<h3 id="ROS简介"><a href="#ROS简介" class="headerlink" title="ROS简介"></a>ROS简介</h3><p>ROS是<strong>分布式的通信框架</strong>，帮助各个进程之间更方便地进行通信，其开发初衷就是<strong>避免重复造轮子</strong>。</p>
<p><strong>常用官方学习网站：</strong></p>
<ul>
<li>官网：www.ros.org</li>
<li>Wiki：www.wiki.ros.org</li>
<li>问答：www.answers.ros.org</li>
</ul>
<h3 id="ROS开发环境"><a href="#ROS开发环境" class="headerlink" title="ROS开发环境"></a>ROS开发环境</h3><p><strong>文件组织方式：</strong>系统空间（/opt/ros）、工作空间</p>
<p><strong>网络通信配置：</strong>分布式开发过程中需要配置<strong>MASTER、HOST</strong>（实战部分再做解释）</p>
<h3 id="ROS框架"><a href="#ROS框架" class="headerlink" title="ROS框架"></a>ROS框架</h3><p> <strong>计算图角度：</strong>节点、话题、服务、动作等</p>
<p><strong>文件系统角度：</strong>源文件空间、编译空间、开发空间</p>
<p><strong>消息机制：</strong>话题、服务、动作</p>
<p><strong>个人理解</strong>：系统各个工作单元在ROS框架下为节点，他们通过各种消息机制获取、发送各类数据、信息，从而使各个部分正常工作形成完整的系统。</p>
<h3 id="ROS节点通信"><a href="#ROS节点通信" class="headerlink" title="ROS节点通信"></a>ROS节点通信</h3><p><strong>话题：</strong>单向异步</p>
<p><strong>服务：</strong>双向同步</p>
<p><strong>动作：</strong>双向异步</p>
<p><strong>服务、动作</strong>均不用构建节点之间的连接。</p>
<h4 id="话题通信"><a href="#话题通信" class="headerlink" title="话题通信"></a>话题通信</h4><p>发布者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/String.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;publish_node&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  ros::Publisher chatter_pub = nh.advertise&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//自循环的频率需要配合27行的sleep()方法使用</span></span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (ros::<span class="built_in">ok</span>()) </span><br><span class="line">  &#123;</span><br><span class="line">    std_msgs::String msg;</span><br><span class="line"></span><br><span class="line">    std::stringstream ss; </span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;hello &quot;</span> &lt;&lt; count; </span><br><span class="line">    msg.data = ss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s&quot;</span>, msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">  </span><br><span class="line">    chatter_pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">  </span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();<span class="comment">//让回调函数有机会被执行的声明</span></span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>订阅者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;std_msgs/String.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chatterCallback</span><span class="params">(<span class="keyword">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;I heard: [%s]&quot;</span>,msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;subscribe_node&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  ros::Subscriber chatter_sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;chatter&quot;</span>, <span class="number">1000</span>,chatterCallback);</span><br><span class="line"></span><br><span class="line">  ros::<span class="built_in">spin</span>();<span class="comment">//让程序进入自循环的挂起状态</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h4><p><strong>自定义服务基本步骤：</strong></p>
<ol>
<li>创建srv文件夹，创建 <strong>.srv</strong> 格式文件，编写消息类型</li>
<li>功能包CMakeLists.txt文件中<strong>find_package</strong>中添加<strong>std_msgs、message_generation</strong>依赖项</li>
<li>解注释<strong>add_service_files</strong> 添加第一步编写的srv文件</li>
<li>解注释<strong>generate_messages</strong> 添加<strong>std_msgs</strong>，其作用是自动创建消息类型的<strong>.h</strong>头文件</li>
<li><strong>package.xml</strong>中添加<strong>message_generation、message_runtime</strong>依赖</li>
</ol>
<p><strong>编译运行注意：</strong>由于自定义了服务消息类型，需在<strong>add_dependencies</strong>中配置<strong>自定义功能包命_gencpp</strong>，若为python则<strong>_genpy</strong></p>
<h4 id="动作通信"><a href="#动作通信" class="headerlink" title="动作通信"></a>动作通信</h4><p><strong>基本步骤：</strong> <strong>find_package</strong>中需添加<strong>Boost库</strong>，其余参照服务通信配置方法</p>
<h3 id="ROS其他重要概念"><a href="#ROS其他重要概念" class="headerlink" title="ROS其他重要概念"></a>ROS其他重要概念</h3><p><strong>parameter：</strong> getParam()、setParam()</p>
<p><strong>tf：</strong> 右手坐标系；由<strong>广播tf变换和监听tf变换</strong>组成节点</p>
<p><strong>nodelet：</strong>该节点可以在单个进程下以多个线程形式运行</p>
<hr>
<h2 id="C-编程规范"><a href="#C-编程规范" class="headerlink" title="C++编程规范"></a>C++编程规范</h2><h3 id="相关学习资料-1"><a href="#相关学习资料-1" class="headerlink" title="相关学习资料"></a>相关学习资料</h3><p>书籍：CMake Practice</p>
<h3 id="编译方式及规范"><a href="#编译方式及规范" class="headerlink" title="编译方式及规范"></a>编译方式及规范</h3><p><strong>编译方式：</strong></p>
<ol>
<li>g++</li>
<li>Make</li>
<li>CMake</li>
</ol>
<p><strong>编程规范：</strong></p>
<p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/">谷歌C++编程风格指南</a></p>
<hr>
<h2 id="OpenCV图像处理"><a href="#OpenCV图像处理" class="headerlink" title="OpenCV图像处理"></a>OpenCV图像处理</h2><h3 id="相关学习资料-2"><a href="#相关学习资料-2" class="headerlink" title="相关学习资料"></a>相关学习资料</h3><p>入门书籍：<a href="http://product.dangdang.com/11058134396.html">OpenCV3编程入门</a></p>
<p>经典书籍（中文翻译版也可以）：<a href="http://product.dangdang.com/27693398.html">Learning Opencv: Computer Vision with the Opencv Library</a></p>
<h3 id="图像数据"><a href="#图像数据" class="headerlink" title="图像数据"></a>图像数据</h3><p><strong>Mat类组成：</strong>矩阵头——存放矩阵尺寸、存储方式、存储地址等信息；矩阵指针——指向内存区域</p>
<p><strong>默认图片存储顺序：</strong>BGR</p>
<h3 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h3><h4 id="线性滤波"><a href="#线性滤波" class="headerlink" title="线性滤波"></a>线性滤波</h4><ul>
<li>均值滤波（blur）</li>
<li>高斯滤波（GaussianBlur）</li>
</ul>
<h4 id="非线性滤波"><a href="#非线性滤波" class="headerlink" title="非线性滤波"></a>非线性滤波</h4><ul>
<li>中值滤波（medianBlur）</li>
<li>双边滤波（bilateralFilter）：与空间位置、像素值相似度有关，能保留细节信息</li>
</ul>
<h4 id="形态学滤波"><a href="#形态学滤波" class="headerlink" title="形态学滤波"></a>形态学滤波</h4><ul>
<li>膨胀（dilate）</li>
<li>腐蚀（erode）</li>
</ul>
<p>不同组合形成新的滤波算法</p>
<ul>
<li>开运算（open）</li>
<li>闭运算（close）</li>
<li>形态学梯度（morphgrad）</li>
<li>顶帽运算（tophat）</li>
<li>黑帽运算（blackhat）</li>
</ul>
<h3 id="图像变换"><a href="#图像变换" class="headerlink" title="图像变换"></a>图像变换</h3><h4 id="射影变换"><a href="#射影变换" class="headerlink" title="射影变换"></a>射影变换</h4><ul>
<li>欧氏变换</li>
<li>相似变换</li>
<li>仿射变换</li>
<li>射影变换（上述三种变换均为射影变换的特例）</li>
</ul>
<h4 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h4><p><strong>检测直线</strong>的一种常用方法</p>
<p><strong>基本原理：</strong>过某一点存在<strong>直线簇</strong>，其对应参数$r、\theta$ 可以绘制一条正弦曲线，若多个点绘制的正弦曲线为同一条曲线，则三点位于同一条直线上</p>
<p><strong>封装函数：</strong>HoughLines、HoughLinesP（累计概率霍夫变换，具有更高的执行效率）</p>
<h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><p><strong>sobel算法：</strong> x、y方向的卷积核对图像卷积，得到两个方向的梯度后合成为某点的近似梯度</p>
<p><strong>canny算法：</strong> 在sobel基础上先用高斯滤波去除噪声，然后sobel算法，最后采用滞后阈值讲边缘提取出来</p>
<h4 id="直方图均衡"><a href="#直方图均衡" class="headerlink" title="直方图均衡"></a>直方图均衡</h4><p><strong>图像直方图：</strong>横坐标为亮度值，纵坐标为每个亮度值对应的像素总数量</p>
<h3 id="图像特征点提取"><a href="#图像特征点提取" class="headerlink" title="图像特征点提取"></a>图像特征点提取</h3><h4 id="SIFT特征点"><a href="#SIFT特征点" class="headerlink" title="SIFT特征点"></a>SIFT特征点</h4><p><strong>尺度空间：</strong>模拟人眼<strong>远近观察</strong>的成像特点，可图区图像中<strong>尺度不变性</strong>的特征</p>
<ul>
<li>图像金字塔</li>
<li>高斯金字塔</li>
<li>高斯差分金字塔（由于<strong>尺度归一化高斯拉普拉斯函数</strong>与<strong>高斯差分函数</strong>非常近似，且差分计算量少）</li>
</ul>
<p><strong>特征点定位：</strong>在<strong>高斯差分金字塔</strong>中完成，<strong>DoG空间进行</strong></p>
<ul>
<li>极值点检测</li>
<li>特征点定位</li>
<li>特征点筛选</li>
</ul>
<p><strong>特征点方向提取：</strong>在<strong>高斯金字塔</strong>中完成</p>
<ul>
<li>特征点主方向</li>
<li>特征点邻域方向</li>
<li>特征点描述子<strong>（4 x 4 x 8 = 128维向量描述）</strong></li>
</ul>
<h4 id="SURF特征点"><a href="#SURF特征点" class="headerlink" title="SURF特征点"></a>SURF特征点</h4><p><strong>尺度空间：</strong>在SIFT基础上讲高斯滤波用<strong>Hessian矩阵的盒式滤波</strong>代替，大幅降低运算耗时；尺度不同问题由盒式滤波窗口尺寸解决</p>
<p><strong>特征点定位：</strong> <strong>Hessian矩阵</strong>的决定值中进行</p>
<p><strong>特征点方向提取：</strong> <strong>Haar小波</strong>特征得到，最终<strong>（4 x 4 x 4 = 64维向量描述）</strong></p>
<h4 id="ORB特征点"><a href="#ORB特征点" class="headerlink" title="ORB特征点"></a>ORB特征点</h4><p><strong>尺度空间：</strong>直接<strong>图像金字塔</strong>拼接成大图</p>
<p><strong>特征点提取：</strong> <strong>FAST特征</strong>提取，结合<strong>灰度质心</strong>得到特征点方向的<strong>oFAST</strong>特征</p>
<p><strong>特征点描述：</strong> 先对图像进行高斯滤波后，采用<strong>BRIEF</strong>描述计算，最后将<strong>BRIEF</strong>中按照高斯分布对特征点方向进行旋转，得到<strong>rBRIEF</strong></p>
<p>​                    </p>
]]></content>
      <tags>
        <tag>ROS</tag>
        <tag>C++</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<span id="more"></span>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>SLAM经典综述学习</title>
    <url>/2022/01/27/SLAM%E7%BB%8F%E5%85%B8%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="SLAM方面经典综述"><a href="#SLAM方面经典综述" class="headerlink" title="SLAM方面经典综述"></a>SLAM方面经典综述</h1><blockquote>
<p><strong>前言：</strong></p>
<p>近期稍有时间，简单过了一遍2016年之前的SLAM方面的经典综述，第一次阅读外文文献，困难颇多，现打算精度一遍，做好相应笔记、总结。</p>
<p>本次整理共计四篇综述如下：</p>
<ol>
<li>Simultaneous localization and mapping(SLAM)-Part I The Essential Algorithms</li>
<li>2006_Simultaneous Localization and Mapping (SLAM)-Part II State of the Art</li>
<li>基于单目视觉的同时定位与地图构建方法综述</li>
<li>Past, Present, and Future of Simultaneous Localization and Mapping- Toward the Robust-Perception Age</li>
</ol>
<p>阅读顺序也是如上顺序，但鉴于当前SLAM方面的后端优化主要采用<strong>图优化</strong>的方式，故本次先总结2016年发表的两篇，后面在对2006年滤波方法两篇做总结<del>（推导太多看不懂）</del></p>
</blockquote>
<hr>
<span id="more"></span>
<h2 id="基于单目视觉的同时定位与地图构建方法综述"><a href="#基于单目视觉的同时定位与地图构建方法综述" class="headerlink" title="基于单目视觉的同时定位与地图构建方法综述"></a>基于单目视觉的同时定位与地图构建方法综述</h2><h3 id="一、写作目的"><a href="#一、写作目的" class="headerlink" title="一、写作目的"></a>一、写作目的</h3><p>室内导航定位的需求以及计算机视觉方面的变革促进出SLAM（simultaneous localization and  mapping）的进一步发展，尤其是低成本的视觉SLAM（V-SLAM）方面更是如此，但在2016年前的综述文献均偏向基于<strong>滤波</strong>的SLAM技术，不能反映如今SLAM技术发展潮流，故针对单目V-SLAM方法进行介绍，同时对V-SLAM最新的研究热点和发展趋势进行总结和展望。</p>
<h3 id="二、V-SLAM基本原理"><a href="#二、V-SLAM基本原理" class="headerlink" title="二、V-SLAM基本原理"></a>二、V-SLAM基本原理</h3><p>通过<strong>多视图几何原理</strong>将三维空间中的三维点变换至相机运动的<strong>运动局部坐标系</strong>中，通过变换后的投影点与图像点进行<strong>最优匹配（最小二乘）</strong>来得到最优的空间三维点和相机运动。</p>
<p>求解最优目标方程的过程也称为<strong>集束调整（BA）</strong>，对其求解通常可利用其系数结构进行高效求解。<em>（注：该部分可参考《机器人感知-因子图在SLAM中的应用》一书，后面再做这本书的学习总结）</em></p>
<p><img src="/2022/01/27/SLAM%E7%BB%8F%E5%85%B8%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0/image-20220127114803347.png" alt="image-20220127114803347" style="zoom:80%;"></p>
<p>​    由于单一视觉对于运动的局限性，所以引入了<strong>IMU</strong>来准确反馈相机的运动，成为了一种新的SLAM——VI-SLAM。</p>
<p>VI-SLAM在V-SLAM的基础上，引入了一个新的运动方程，使得待优化的目标函数从原来的：</p>
<script type="math/tex; mode=display">
\underset{C_1\cdots C_m,X_1\cdots X_n}{\mathrm{argmin}} \sum_{i=1}^m \sum_{j=1}^n\|h(C_i,X_j)-\hat x_{ij}\|_{\sum_{ij}}</script><p>​    引入运动方程后变为：</p>
<script type="math/tex; mode=display">
\underset{C_1\cdots C_m,X_1\cdots X_n}{\mathrm{argmin}} \sum_{i=1}^m \sum_{j=1}^n\|h(C_i,X_j)-\hat x_{ij}\|_{\sum_{ij}} + \sum_{i=1}^{m-1}\|f(C_i,Z_i)-C_{i+1}\|_{\Gamma_i}</script><p>​    同理，若融合GPS数据，则再引入一项，且均假设数据观测符合<strong>高斯分布</strong>。</p>
<h3 id="三、代表性单目V-SLAM系统"><a href="#三、代表性单目V-SLAM系统" class="headerlink" title="三、代表性单目V-SLAM系统"></a>三、代表性单目V-SLAM系统</h3><h4 id="3-1基于滤波器的V-SLAM"><a href="#3-1基于滤波器的V-SLAM" class="headerlink" title="3.1基于滤波器的V-SLAM"></a>3.1基于滤波器的V-SLAM</h4><h5 id="3-1-1-MonoSLAM"><a href="#3-1-1-MonoSLAM" class="headerlink" title="3.1.1 MonoSLAM"></a>3.1.1 MonoSLAM</h5><p>单目视觉SLAM，基于<strong>卡尔曼滤波优化模型</strong>，概率预测时体现为椭圆球的概率范围，采取每帧图片中的<strong>Shi-Tomasi</strong>角点为特征点进行匹配。</p>
<p><img src="/2022/01/27/SLAM%E7%BB%8F%E5%85%B8%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0/image-20220127143446455.png" alt="image-20220127143446455" style="zoom:80%;"></p>
<p><strong>缺点：</strong>受限于EKF的局限性：</p>
<ol>
<li>如果预测函数和更新函数为非线性(通常 V-SLAM 问题都是非线性的)，那么 EKF 并不能保证全局最优，与 Levenberg-Marquardt[20]等迭代的非线性优化技术相比，更容易造成误差累积。</li>
<li>若将三维点引入状态变量，则每一时刻的计算复杂度为$O(n^3)$，因此只能处理几百个点的小场景。</li>
</ol>
<h5 id="3-1-2-MSCKF"><a href="#3-1-2-MSCKF" class="headerlink" title="3.1.2 MSCKF"></a>3.1.2 MSCKF</h5><p>缓解了EKF方法的计算复杂度问题的一种VI-SLAM</p>
<ol>
<li><strong>更新阶段</strong>改进为包含临近 $l$ 帧的状态集合进行优化；</li>
<li>对所有三维点进行消元使原来的二元约束转化为多元约束，计算复杂度降低至$O(nl^3)$</li>
</ol>
<h4 id="3-2基于关键帧BA的V-SLAM"><a href="#3-2基于关键帧BA的V-SLAM" class="headerlink" title="3.2基于关键帧BA的V-SLAM"></a>3.2基于关键帧BA的V-SLAM</h4><h5 id="3-2-1-PTAM"><a href="#3-2-1-PTAM" class="headerlink" title="3.2.1 PTAM"></a>3.2.1 PTAM</h5><p>基本思想： 将相机跟踪(Tracking)和地图构建(Mapping)作为 2 个独立的任务在 2 个线程并行执行。地图构建线程仅维护原视频流中稀疏抽取的关键帧(如图 a 所示)及关键帧中可见的三维点(如图 b 所示)，这样就可以非常高效地求解目标函数(即 BA)；有了 BA 恢复的精确三维结构，相机跟踪线程作为前台线程，仅需优化当前帧运动参数 $C_i$， 足以达到实时的计算效率。</p>
<p><img src="/2022/01/27/SLAM%E7%BB%8F%E5%85%B8%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0/image-20220127144005880.png" alt="image-20220127144005880" style="zoom:80%;"></p>
<p>​    追踪<strong>FAST角点</strong>作为主要特征点。</p>
<h5 id="3-2-2-ORB-SLAM"><a href="#3-2-2-ORB-SLAM" class="headerlink" title="3.2.2 ORB-SLAM"></a>3.2.2 ORB-SLAM</h5><p>在PTAM基础上改进的目前性能最好的单目V-SLAM系统之一：</p>
<ol>
<li>采用<strong>ORB</strong>特征；</li>
<li>加入<strong>循环回路</strong>和<strong>闭合机制</strong>;</li>
<li>可自动选择初始化的2帧图片；</li>
<li>先宽松判断条件使系统尽可能多的加入新的关键帧及三维点，保证后续帧的鲁棒跟踪，再用严格的判断条件删除冗余的关键帧和不稳定的三维点。</li>
</ol>
<p><img src="/2022/01/27/SLAM%E7%BB%8F%E5%85%B8%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0/image-20220127193607859.png" alt="image-20220127193607859" style="zoom:80%;"></p>
<p><em>（注：ORB-SLAM相关内容后续根据ORB-SLAM2框架进行总结）</em></p>
<h4 id="3-3-基于直接跟踪的V-SLAM"><a href="#3-3-基于直接跟踪的V-SLAM" class="headerlink" title="3.3 基于直接跟踪的V-SLAM"></a>3.3 基于直接跟踪的V-SLAM</h4><h5 id="3-3-1-DTAM"><a href="#3-3-1-DTAM" class="headerlink" title="3.3.1 DTAM"></a>3.3.1 DTAM</h5><p>其最显著的特点是能实时恢复场景三维模型。 基于三维模型，DTAM 既能允许 AR应用中的虚拟物体与场景发生物理碰撞，又能保证在特征缺失、图像模糊等情况下稳定地直接跟踪。</p>
<p><img src="/2022/01/27/SLAM%E7%BB%8F%E5%85%B8%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0/image-20220127194000642.png" alt="image-20220127194000642" style="zoom:80%;"></p>
<h5 id="3-3-2-LSD-SLAM"><a href="#3-3-2-LSD-SLAM" class="headerlink" title="3.3.2 LSD-SLAM"></a>3.3.2 LSD-SLAM</h5><p>仅恢复<strong>半稠密</strong>的深度图，且每个像素的深度能够独立计算，从而提高了计算效率。采用<strong>关键帧</strong>表达场景，<strong>方位图优化</strong>进行闭合循环和大尺度场景的应用。</p>
<p><img src="/2022/01/27/SLAM%E7%BB%8F%E5%85%B8%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0/image-20220127194304616.png" alt="image-20220127194304616" style="zoom:80%;"></p>
<h4 id="3-4-比较与分析"><a href="#3-4-比较与分析" class="headerlink" title="3.4 比较与分析"></a>3.4 比较与分析</h4><p><strong>性能指标：</strong></p>
<ol>
<li>定位精度</li>
<li>定位效率</li>
<li>场景尺度</li>
<li>特征缺失鲁棒性</li>
<li>重定位能力</li>
<li>快速运动鲁棒性</li>
<li>扩展效率</li>
<li>近似纯旋转扩展鲁棒性</li>
<li>场景变化鲁棒性</li>
<li>回路闭合能力</li>
</ol>
<p><img src="/2022/01/27/SLAM%E7%BB%8F%E5%85%B8%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0/image-20220127194555865.png" alt="image-20220127194555865"></p>
<p>具体分析由各部分系统的特性决定，各个系统的优缺点也依赖于系统的实现。</p>
<h3 id="四、研究热点与发展趋势"><a href="#四、研究热点与发展趋势" class="headerlink" title="四、研究热点与发展趋势"></a>四、研究热点与发展趋势</h3><h5 id="4-1缓解特征依赖"><a href="#4-1缓解特征依赖" class="headerlink" title="4.1缓解特征依赖"></a>4.1缓解特征依赖</h5><p>V-SLAM的局限就在于依赖场景特征，如何减少对场景特征依赖的同时，提高对特征信息的高效利用是一个重要的提高V-SLAM系统性能的方向。</p>
<p>现有方法包括<strong>物体边缘、平面颜色</strong>等方面的应用。</p>
<h5 id="4-2-稠密三维重建"><a href="#4-2-稠密三维重建" class="headerlink" title="4.2 稠密三维重建"></a>4.2 稠密三维重建</h5><p>得益于深度相机的出现，三维建模开始进入发展阶段，同时AR方面更是基于三维建模的基础上去开展的。</p>
<p>如何处理有限的算力去完成三维建模这样大规模的数据处理是研究的重点，同时三维建模也逐渐引入深度学习方面的技术进行融合。</p>
<h5 id="4-3-多传感器融合"><a href="#4-3-多传感器融合" class="headerlink" title="4.3 多传感器融合"></a>4.3 多传感器融合</h5><p>这个不必多说，VI-SLAM便是典型代表，如何使用多传感器去融合得到的场景信息，提高建图效率、精度是当前研究的热点方向。</p>
<h5 id="4-4-实际发展问题"><a href="#4-4-实际发展问题" class="headerlink" title="4.4 实际发展问题"></a>4.4 实际发展问题</h5><p>用户的不专业操作、实际场景的复杂情况都是当前SLAM研究需要解决的方向问题。</p>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>本文是建立在自己对SLAM整体框架大致了解的基础上去学习的，所有整体看下来没有太多阻塞的地方。其中最收获最多的地方应该是直接跟踪建图部分的SLAM系统的介绍，这也是当前稠密建图的基础。第三部分的性能比较，也让我了解到各个系统之间的优劣所在，知道应该以什么方向、什么指标去评定一个SLAM系统。</p>
<p>本文总结于22年，距离文章发表的16年已有6年之多，其中感触最深刻的应该还是三维建模的方面的应用，融入了深度学习的三维建模已逐渐在无人驾驶、AR、XR等领域展露拳脚，同时ORB-SLAM3的开源，更是“灭霸”般的存在。下个时代的代表综述只会更加精彩。</p>
<h4 id="六、思维导图"><a href="#六、思维导图" class="headerlink" title="六、思维导图"></a>六、思维导图</h4><p><img src="/2022/01/27/SLAM%E7%BB%8F%E5%85%B8%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0/基于单目视觉的同时定位与地图构建方法综述_00.jpg" alt="基于单目视觉的同时定位与地图构建方法综述_00" style="zoom:80%;"></p>
]]></content>
      <tags>
        <tag>SLAM</tag>
        <tag>Paper Reading</tag>
      </tags>
  </entry>
</search>
